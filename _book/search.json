[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Thinking Bayesian",
    "section": "",
    "text": "Willkommen",
    "crumbs": [
      "Willkommen"
    ]
  },
  {
    "objectID": "index.html#bayesian-thinking-mit-python",
    "href": "index.html#bayesian-thinking-mit-python",
    "title": "Thinking Bayesianâ€",
    "section": "Bayesian Thinking mit Python",
    "text": "Bayesian Thinking mit Python\nHerzlich willkommen zu diesem Self-Paced Workshop.\nHier lernst du nicht nur graue Theorie, sondern entwickelst ein intuitives GefÃ¼hl fÃ¼r Bayesianische Statistik. Wir nutzen moderne Tools, um Konzepte sichtbar und anfassbar zu machen.\nDas Besondere: Dieser Kurs ist vollkommen interaktiv. Alle Diagramme, Simulationen und Modelle laufen direkt hier in deinem Browser.\n\nWas dich erwartet\n\nğŸ“ Intuition statt Formel-WÃ¼ste: Wir starten mit dem â€œWarumâ€.\nğŸ Modernes Python: Wir nutzen den neuen Shiny-fÃ¼r-Python Stack.\nâš¡ Interaktiv: Keine statischen Bilder. Du steuerst die Parameter.",
    "crumbs": [
      "Willkommen"
    ]
  },
  {
    "objectID": "index.html#der-fahrplan",
    "href": "index.html#der-fahrplan",
    "title": "Thinking Bayesian",
    "section": "Der Fahrplan",
    "text": "Der Fahrplan\n\n\n\nModul\nInhalt\nStatus\n\n\n\n\n00\nSetup & Intro\nâœ… Offen\n\n\n01\nBayesian Thinking\nğŸ”¥ Empfohlen\n\n\n02\nBayes vs.Â Frequentist\nğŸ§¬ Deep Dive\n\n\n\n\nDieser Workshop wurde mit Quarto und Shinylive erstellt.",
    "crumbs": [
      "Willkommen"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "1Â  Setup & Installation",
    "section": "",
    "text": "1.1 Option A: Der Browser-Weg (Empfohlen)\nDas Beste vorweg: Du brauchst keine Software zu installieren, um diesen Workshop durchzufÃ¼hren.\nDank moderner WebAssembly-Technologie (WASM) lÃ¤uft der gesamte Python-Code, den du hier siehst, direkt in deinem Browser. Dein Computer ist der Server.\nLehne dich zurÃ¼ck. Wenn du die interaktiven Apps siehst, hat dein Browser bereits im Hintergrund eine kleine Python-Umgebung geladen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Setup & Installation</span>"
    ]
  },
  {
    "objectID": "setup.html#option-a-der-browser-weg-empfohlen",
    "href": "setup.html#option-a-der-browser-weg-empfohlen",
    "title": "1Â  Setup & Installation",
    "section": "",
    "text": "âœ… Keine Installation\nâœ… Funktioniert auf Windows, Mac, Linux & iPad\nâœ… Datenschutzfreundlich (Daten verlassen deinen PC nicht)\n\n\n\n\n\n\n\nNoteLadezeit\n\n\n\nBeim allerersten Laden einer Seite kann es 1-2 Sekunden dauern, bis Python initialisiert ist. Danach geht es blitzschnell.",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Setup & Installation</span>"
    ]
  },
  {
    "objectID": "setup.html#option-b-lokal-mit-vs-code-fÃ¼r-profis",
    "href": "setup.html#option-b-lokal-mit-vs-code-fÃ¼r-profis",
    "title": "1Â  Setup & Installation",
    "section": "1.2 Option B: Lokal mit VS Code (FÃ¼r Profis)",
    "text": "1.2 Option B: Lokal mit VS Code (FÃ¼r Profis)\nWenn du den Code aus diesem Workshop kopieren und auf deinem eigenen Rechner weiterentwickeln mÃ¶chtest, empfehlen wir folgendes Setup.\n\n1.2.1 1. Python installieren\nStelle sicher, dass du Python 3.9 oder neuer installiert hast.\n\n\n1.2.2 2. Virtuelles Environment\nErstelle in deinem Projektordner eine isolierte Umgebung:\n```bash # Windows python -m venv .venv .venv",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Setup & Installation</span>"
    ]
  },
  {
    "objectID": "01-bayes-intro.html",
    "href": "01-bayes-intro.html",
    "title": "2Â  The Logic of Uncertainty",
    "section": "",
    "text": "2.1 The Scenario: A Rare Disease\nWe begin with a concrete scenario common in medical diagnostics to understand why human intuition often fails at probability and how Bayesian reasoning provides the correct framework.\nImagine a disease that affects 1% of the population (the prevalence). There is a test for this disease that is 99% accurate. Specifically: 1. Sensitivity: If you have the disease, the test is positive 99% of the time. 2. Specificity: If you do not have the disease, the test is negative 99% of the time.\nThe Problem: A patient takes the test and receives a Positive result. Intuitively, most people (and even many doctors) assume the probability the patient has the disease is near 99%.\nThe Reality: The actual probability is only 50%.",
    "crumbs": [
      "Modul 1: Becomming Bayesian",
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>The Logic of Uncertainty</span>"
    ]
  },
  {
    "objectID": "01-bayes-intro.html#die-formel-ganz-entspannt",
    "href": "01-bayes-intro.html#die-formel-ganz-entspannt",
    "title": "2Â  EinfÃ¼hrung in Bayesian Thinking",
    "section": "",
    "text": "NoteMerksatz\n\n\n\nDein neues Wissen (Posterior) ist eine Mischung aus dem, was du gesehen hast (Likelihood) und dem, was du vorher geglaubt hast (Prior).",
    "crumbs": [
      "Modul 1: Becomming Bayesian",
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>The Logic of Uncertainty</span>"
    ]
  },
  {
    "objectID": "01-bayes-intro.html#interaktives-labor-der-mÃ¼nzwurf",
    "href": "01-bayes-intro.html#interaktives-labor-der-mÃ¼nzwurf",
    "title": "2Â  EinfÃ¼hrung in Bayesian Thinking",
    "section": "2.2 ğŸ§ª Interaktives Labor: Der MÃ¼nzwurf",
    "text": "2.2 ğŸ§ª Interaktives Labor: Der MÃ¼nzwurf\nLass uns das testen. Wir wollen wissen: Ist diese MÃ¼nze fair?\n\nPrior (Blau): Was glaubst du bevor du wirfst? (0.5 = Fair, 0.8 = Gezinkt auf Kopf).\nDaten: Wie oft ist â€œKopfâ€ gefallen?\n\nVerÃ¤ndere die Regler und beobachte, wie sich die rote Kurve (dein neues Wissen) verÃ¤ndert.\n#| standalone: true\n#| viewerHeight: 500\n\nfrom shiny import App, render, ui\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import beta\n\napp_ui = ui.page_fillable(\n    ui.layout_columns(\n        ui.card(\n            ui.card_header(\"ğŸ›ï¸ Dein Experiment\"),\n            ui.input_slider(\"prior_belief\", \"Dein Vorwissen (Prior Mean):\", 0.0, 1.0, 0.5),\n            ui.input_slider(\"confidence\", \"Wie sicher bist du dir? (Prior Strength)\", 2, 50, 4),\n            ui.hr(),\n            ui.h5(\"Die Daten\"),\n            ui.input_slider(\"heads\", \"Anzahl 'Kopf' geworfen:\", 0, 50, 10),\n            ui.input_slider(\"tails\", \"Anzahl 'Zahl' geworfen:\", 0, 50, 10),\n        ),\n        ui.card(\n            ui.card_header(\"ğŸ“ˆ Wissens-Update\"),\n            ui.output_plot(\"bayes_plot\"),\n        ),\n        col_widths=[4, 8]\n    )\n)\n\ndef server(input, output, session):\n    @render.plot\n    def bayes_plot():\n        # 1. Prior Parameter berechnen (Beta Distribution)\n        # Wir wandeln \"Glaube\" (Mean) und \"Sicherheit\" (Sample Size) in Alpha/Beta um\n        prior_mean = input.prior_belief()\n        prior_n = input.confidence()\n        \n        alpha_prior = prior_mean * prior_n\n        beta_prior = (1 - prior_mean) * prior_n\n        \n        # 2. Daten\n        heads = input.heads()\n        tails = input.tails()\n        \n        # 3. Posterior berechnen (Konjugierte Priors sind einfach Addition!)\n        alpha_post = alpha_prior + heads\n        beta_post = beta_prior + tails\n        \n        # Plotting\n        x = np.linspace(0, 1, 200)\n        \n        fig, ax = plt.subplots()\n        \n        # Prior Plot\n        y_prior = beta.pdf(x, alpha_prior, beta_prior)\n        ax.plot(x, y_prior, label='Prior (Vorwissen)', color='skyblue', linestyle='--', lw=2)\n        ax.fill_between(x, 0, y_prior, color='skyblue', alpha=0.2)\n        \n        # Posterior Plot\n        y_post = beta.pdf(x, alpha_post, beta_post)\n        ax.plot(x, y_post, label='Posterior (Nach Update)', color='#e67e22', lw=3)\n        ax.fill_between(x, 0, y_post, color='#e67e22', alpha=0.4)\n        \n        ax.set_title(\"Wie wahrscheinlich ist 'Kopf'? (Theta)\", fontsize=14)\n        ax.set_xlabel(\"Wahrscheinlichkeit fÃ¼r Kopf (0 = Nie, 1 = Immer)\")\n        ax.set_yticks([])\n        ax.legend()\n        ax.spines['top'].set_visible(False)\n        ax.spines['right'].set_visible(False)\n        \n        return fig\n\napp = App(app_ui, server)\n\n\n\n\n\n\nTipExperimentier-Idee\n\n\n\nStelle das Vorwissen auf 0.5 (Fair), aber die Sicherheit (Confidence) ganz hoch auf 50. Dann wirf 10 mal Kopf und 0 mal Zahl. Beobachtung: Die rote Kurve bewegt sich kaum. Warum? Weil ein starker Prior (Starrsinn) schwer durch wenige Daten zu erschÃ¼ttern ist!",
    "crumbs": [
      "Modul 1: Becomming Bayesian",
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>The Logic of Uncertainty</span>"
    ]
  },
  {
    "objectID": "02-bayes-vs-frequentist.html",
    "href": "02-bayes-vs-frequentist.html",
    "title": "3Â  Bayesian vs.Â Frequentist",
    "section": "",
    "text": "3.1 The Scenario: Marketing Conversion\nIn this chapter, we contrast the two dominant statistical philosophies using a standard industry problem: A/B Testing.\nYou run an e-commerce website. You are testing two versions of a checkout button: * Version A (Control): Blue Button. * Version B (Treatment): Red Button.\nYou collect data from 1,000 users.",
    "crumbs": [
      "Modul 2: Frequently Updated",
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Bayesian vs. Frequentist</span>"
    ]
  },
  {
    "objectID": "02-bayes-vs-frequentist.html#die-philosophie",
    "href": "02-bayes-vs-frequentist.html#die-philosophie",
    "title": "3Â  Bayesian vs.Â Frequentist",
    "section": "",
    "text": "Feature\nFrequentistisch ğŸ›ï¸\nBayesianisch ğŸ”®\n\n\n\n\nDer Parameter\nIst fest (aber unbekannt).\nIst eine Zufallsvariable.\n\n\nDas Intervall\nâ€œIn 95% der Wiederholungen fÃ¤ngt mein Intervall den wahren Wert.â€\nâ€œMit 95% Wahrscheinlichkeit liegt der wahre Wert hier drin.â€\n\n\nVorwissen\nNicht erlaubt / Ignoriert.\nExplizit als Prior modelliert.",
    "crumbs": [
      "Modul 2: Frequently Updated",
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Bayesian vs. Frequentist</span>"
    ]
  },
  {
    "objectID": "02-bayes-vs-frequentist.html#der-visuelle-vergleich",
    "href": "02-bayes-vs-frequentist.html#der-visuelle-vergleich",
    "title": "3Â  Bayesian vs.Â Frequentist",
    "section": "3.2 ğŸ“Š Der visuelle Vergleich",
    "text": "3.2 ğŸ“Š Der visuelle Vergleich\nWir schÃ¤tzen den Mittelwert einer Gruppe. Unten siehst du den Unterschied im Ergebnis.\n\nLinks (Frequentist): Du bekommst einen Punkt (SchÃ¤tzer) und Fehlerbalken. Wir treffen keine Aussage Ã¼ber Wahrscheinlichkeiten innerhalb des Balkens.\nRechts (Bayesian): Du bekommst eine komplette Kurve. Wir wissen, wo der Wert am wahrscheinlichsten ist (die Spitze) und wie unsicher wir sind (die Breite).\n\n#| standalone: true\n#| viewerHeight: 450\n\nfrom shiny import App, render, ui\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\n\napp_ui = ui.page_fillable(\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.h4(\"Daten Generator\"),\n            ui.input_slider(\"n\", \"StichprobengrÃ¶ÃŸe (n)\", 5, 100, 30),\n            ui.input_slider(\"true_mu\", \"Wahre Mean\", -5, 5, 2),\n            ui.input_slider(\"noise\", \"Rauschen (SD)\", 0.5, 5, 2),\n            bg=\"#f8f9fa\"\n        ),\n        ui.layout_columns(\n            ui.card(ui.output_plot(\"plot_freq\")),\n            ui.card(ui.output_plot(\"plot_bayes\")),\n        )\n    )\n)\n\ndef server(input, output, session):\n    \n    # Reaktive Berechnung der Daten, damit beide Plots dasselbe nutzen\n    def get_data():\n        np.random.seed(42) # FÃ¼r StabilitÃ¤t im Workshop\n        return np.random.normal(input.true_mu(), input.noise(), input.n())\n\n    @render.plot\n    def plot_freq():\n        data = get_data()\n        mu_hat = np.mean(data)\n        sem = stats.sem(data)\n        ci = stats.t.interval(0.95, len(data)-1, loc=mu_hat, scale=sem)\n        \n        fig, ax = plt.subplots()\n        # Visualisierung als Konfidenzintervall\n        ax.errorbar(mu_hat, 1, xerr=(ci[1]-ci[0])/2, fmt='o', capsize=10, \n                    color='black', label='Mean Estimate')\n        \n        # Den \"Wahren Wert\" einzeichnen (den wir eigentlich nicht kennen)\n        ax.axvline(input.true_mu(), color='red', linestyle=':', label='Wahrer Wert')\n        \n        ax.set_title(\"Frequentist View\\n(95% Confidence Interval)\")\n        ax.set_yticks([])\n        ax.set_xlim(-8, 8)\n        ax.legend(loc='upper left')\n        return fig\n\n    @render.plot\n    def plot_bayes():\n        data = get_data()\n        # Vereinfachtes Bayes Update (Normal-Normal Conjugate, flat prior)\n        # Bei flachem Prior entspricht der Posterior Mean dem Sample Mean\n        mu_hat = np.mean(data)\n        sigma_hat = np.std(data, ddof=1)\n        n = len(data)\n        \n        # Posterior Standard Deviation (Ã¤hnlich SEM)\n        post_std = sigma_hat / np.sqrt(n)\n        \n        x = np.linspace(-8, 8, 200)\n        y = stats.norm.pdf(x, mu_hat, post_std)\n        \n        fig, ax = plt.subplots()\n        ax.plot(x, y, color='#2ecc71', lw=3)\n        ax.fill_between(x, 0, y, color='#2ecc71', alpha=0.3)\n        \n        # 95% Credible Interval (Highest Density Interval)\n        hdi = stats.norm.interval(0.95, loc=mu_hat, scale=post_std)\n        ax.axvline(hdi[0], color='green', linestyle='--')\n        ax.axvline(hdi[1], color='green', linestyle='--')\n        \n        ax.axvline(input.true_mu(), color='red', linestyle=':', label='Wahrer Wert')\n        \n        ax.set_title(\"Bayesian View\\n(Posterior Distribution)\")\n        ax.set_yticks([])\n        ax.set_xlim(-8, 8)\n        return fig\n\napp = App(app_ui, server)\n\n\n\n\n\n\nWarningVorsicht beim Vergleich\n\n\n\nAchte darauf, was passiert, wenn n (StichprobengrÃ¶ÃŸe) klein ist. Der Frequentist (Links) gibt dir oft ein sehr breites Intervall, sagt aber nichts darÃ¼ber aus, ob der Wert eher in der Mitte oder am Rand liegt. Der Bayesianer (Rechts) quantifiziert genau, welche Werte wahrscheinlicher sind (der â€œHÃ¼gelâ€).",
    "crumbs": [
      "Modul 2: Frequently Updated",
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Bayesian vs. Frequentist</span>"
    ]
  },
  {
    "objectID": "01-bayes-intro.html#the-failure-of-intuition",
    "href": "01-bayes-intro.html#the-failure-of-intuition",
    "title": "2Â  The Logic of Uncertainty",
    "section": "2.2 The Failure of Intuition",
    "text": "2.2 The Failure of Intuition\nWhy is the intuitive answer wrong? It ignores the Prior (the prevalence). Because the disease is rare, the absolute number of False Positives from the massive healthy population overwhelms the True Positives from the tiny sick population.\nBayesian thinking forces us to account for this base rate.",
    "crumbs": [
      "Modul 1: Becomming Bayesian",
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>The Logic of Uncertainty</span>"
    ]
  },
  {
    "objectID": "01-bayes-intro.html#the-bayesian-solution",
    "href": "01-bayes-intro.html#the-bayesian-solution",
    "title": "2Â  The Logic of Uncertainty",
    "section": "2.3 The Bayesian Solution",
    "text": "2.3 The Bayesian Solution\nWe do not look at the test accuracy in isolation. We update our prior belief based on the evidence.\n\\[P(\\text{Disease} | \\text{Positive}) = \\frac{P(\\text{Positive} | \\text{Disease}) \\cdot P(\\text{Disease})}{P(\\text{Positive})}\\]\n\n2.3.1 Interactive Simulation\nUse the dashboard below to visualize this relationship. 1. Set the Prevalence to a low number (e.g., 0.01). 2. Keep Sensitivity and Specificity high (0.99). 3. Observe the bar chart. Note how the â€œFalse Positivesâ€ (Red) compete with the â€œTrue Positivesâ€ (Green).\n```vzufmjaqcnzvlukcyj #| standalone: true #| viewerHeight: 550\nfrom shiny import App, render, ui import matplotlib.pyplot as plt import numpy as np\napp_ui = ui.page_fillable( ui.layout_columns( ui.card( ui.card_header(â€œDiagnostic Parametersâ€), ui.input_slider(â€œprevalenceâ€, â€œPrevalence (Prior Belief)â€, 0.001, 0.1, 0.01, step=0.001), ui.input_slider(â€œsensitivityâ€, â€œSensitivity (True Positive Rate)â€, 0.9, 1.0, 0.99, step=0.001), ui.input_slider(â€œspecificityâ€, â€œSpecificity (True Negative Rate)â€, 0.9, 1.0, 0.99, step=0.001), ui.hr(), ui.output_text_verbatim(â€œresult_textâ€) ), ui.card( ui.card_header(â€œPopulation Breakdownâ€), ui.output_plot(â€œbayes_plotâ€), ), col_widths=[4, 8] ) )\ndef server(input, output, session):\n@render.text\ndef result_text():\n    # calculations\n    prev = input.prevalence()\n    sens = input.sensitivity()\n    spec = input.specificity()\n    \n    # Bayes Theorem\n    p_pos_given_disease = sens\n    p_pos_given_healthy = 1 - spec\n    \n    numerator = p_pos_given_disease * prev\n    denominator = numerator + (p_pos_given_healthy * (1 - prev))\n    \n    post_prob = numerator / denominator\n    \n    return f\"Probability of Disease given Positive Test:\\n{post_prob:.1%}\"\n\n@render.plot\ndef bayes_plot():\n    prev = input.prevalence()\n    sens = input.sensitivity()\n    spec = input.specificity()\n    \n    # Hypothetical population of 10,000\n    n_pop = 10000\n    n_sick = n_pop * prev\n    n_healthy = n_pop * (1 - prev)\n    \n    # Outcomes\n    true_pos = n_sick * sens\n    false_neg = n_sick * (1 - sens)\n    \n    true_neg = n_healthy * spec\n    false_pos = n_healthy * (1 - spec)\n    \n    # Plotting\n    fig, ax = plt.subplots()\n    \n    # Data for stacked bars\n    categories = ['Sick Population', 'Healthy Population']\n    \n    # Bar 1: Sick (Split into Detected and Missed)\n    ax.bar(0, true_pos, color='#27ae60', label='True Positive (Correct)', width=0.6)\n    ax.bar(0, false_neg, bottom=true_pos, color='#2c3e50', label='False Negative (Missed)', width=0.6, alpha=0.3)\n    \n    # Bar 2: Healthy (Split into True Negative and False Alarm)\n    ax.bar(1, false_pos, color='#c0392b', label='False Positive (Alarm)', width=0.6)\n    ax.bar(1, true_neg, bottom=false_pos, color='#95a5a6', label='True Negative (Correct)', width=0.6, alpha=0.3)\n    \n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(categories)\n    ax.set_ylabel(\"Number of People\")\n    ax.set_title(f\"Visualizing the Base Rate Fallacy (N={n_pop})\")\n    \n    # Annotation to highlight the comparison\n    ax.annotate(f\"{int(true_pos)} True Pos\", xy=(0, true_pos/2), ha='center', color='white', fontweight='bold')\n    if false_pos &gt; 5:\n        ax.annotate(f\"{int(false_pos)} False Pos\", xy=(1, false_pos/2), ha='center', color='white', fontweight='bold')\n    \n    ax.legend()\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    \n    return fig\napp = App(app_ui, server)",
    "crumbs": [
      "Modul 1: Becomming Bayesian",
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>The Logic of Uncertainty</span>"
    ]
  },
  {
    "objectID": "02-bayes-vs-frequentist.html#the-frequentist-approach-the-problem",
    "href": "02-bayes-vs-frequentist.html#the-frequentist-approach-the-problem",
    "title": "3Â  Bayesian vs.Â Frequentist",
    "section": "3.2 The Frequentist Approach (The Problem)",
    "text": "3.2 The Frequentist Approach (The Problem)\nIn a traditional Frequentist framework (e.g., a t-test or Chi-square), you calculate a p-value.\nIf \\(p &lt; 0.05\\), you reject the null hypothesis. However, this approach has significant limitations for decision-making: 1. Indirect Meaning: The p-value tells you the probability of seeing this data assuming there is no difference. It does not tell you the probability that Version B is better. 2. Point Estimates: It often provides a single point estimate (e.g., â€œConversion increased by 2%â€), hiding the uncertainty distribution. 3. Peeking: You are strictly forbidden from checking results early (stopping rules), which is impractical in business.",
    "crumbs": [
      "Modul 2: Frequently Updated",
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Bayesian vs. Frequentist</span>"
    ]
  },
  {
    "objectID": "02-bayes-vs-frequentist.html#the-bayesian-approach-the-solution",
    "href": "02-bayes-vs-frequentist.html#the-bayesian-approach-the-solution",
    "title": "3Â  Bayesian vs.Â Frequentist",
    "section": "3.3 The Bayesian Approach (The Solution)",
    "text": "3.3 The Bayesian Approach (The Solution)\nBayesian statistics answers the question you actually care about: â€œWhat is the probability that Version B is better than Version A?â€\nWe model the conversion rate of each version not as a fixed number, but as a distribution of possibilities. By comparing these two distributions, we can calculate direct probabilities of improvement/loss.\n\n3.3.1 Interactive Analysis\nThe simulation below models two conversion rates using Beta distributions. * Problem: We observe raw data (trials and conversions). * Solution: We visualize the uncertainty and calculate the â€œProbability of Improvement.â€\n```gdzcgnjehlqgmbcrfa #| standalone: true #| viewerHeight: 500\nfrom shiny import App, render, ui import matplotlib.pyplot as plt import numpy as np from scipy.stats import beta\napp_ui = ui.page_fillable( ui.layout_columns( ui.card( ui.card_header(â€œExperiment Dataâ€), ui.h5(â€œVersion A (Control)â€), ui.input_slider(â€œtrials_aâ€, â€œVisitors Aâ€, 10, 1000, 500), ui.input_slider(â€œconv_aâ€, â€œConversions Aâ€, 1, 200, 50), ui.hr(), ui.h5(â€œVersion B (Treatment)â€), ui.input_slider(â€œtrials_bâ€, â€œVisitors Bâ€, 10, 1000, 500), ui.input_slider(â€œconv_bâ€, â€œConversions Bâ€, 1, 200, 60),\n        ui.output_text_verbatim(\"prob_statement\")\n    ),\n    ui.card(\n        ui.card_header(\"Posterior Distributions\"),\n        ui.output_plot(\"ab_plot\"),\n    ),\n    col_widths=[4, 8]\n)\n)\ndef server(input, output, session):\n@render.text\ndef prob_statement():\n    # Monte Carlo Simulation to calculate Prob(B &gt; A)\n    # This is often easier/faster than numerical integration for A/B tests\n    \n    a_samples = beta.rvs(1 + input.conv_a(), 1 + (input.trials_a() - input.conv_a()), size=10000)\n    b_samples = beta.rvs(1 + input.conv_b(), 1 + (input.trials_b() - input.conv_b()), size=10000)\n    \n    prob_b_better = np.mean(b_samples &gt; a_samples)\n    \n    return (f\"Based on this data:\\n\"\n            f\"There is a {prob_b_better:.1%} probability\\n\"\n            f\"that Version B is better than Version A.\")\n\n@render.plot\ndef ab_plot():\n    # Define x-axis range around the observed means to zoom in\n    mean_a = input.conv_a() / input.trials_a()\n    mean_b = input.conv_b() / input.trials_b()\n    avg_mean = (mean_a + mean_b) / 2\n    \n    x = np.linspace(max(0, avg_mean - 0.1), min(1, avg_mean + 0.1), 300)\n    \n    # Beta parameters (Flat prior alpha=1, beta=1 assumed)\n    y_a = beta.pdf(x, 1 + input.conv_a(), 1 + (input.trials_a() - input.conv_a()))\n    y_b = beta.pdf(x, 1 + input.conv_b(), 1 + (input.trials_b() - input.conv_b()))\n    \n    fig, ax = plt.subplots()\n    \n    # Plot A\n    ax.plot(x, y_a, label='Version A', color='blue', lw=2)\n    ax.fill_between(x, 0, y_a, color='blue', alpha=0.1)\n    \n    # Plot B\n    ax.plot(x, y_b, label='Version B', color='red', lw=2)\n    ax.fill_between(x, 0, y_b, color='red', alpha=0.1)\n    \n    ax.set_title(\"Uncertainty of Conversion Rates\")\n    ax.set_xlabel(\"True Conversion Rate\")\n    ax.set_yticks([]) # Hide y-axis as density magnitude is less intuitive\n    ax.legend()\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['left'].set_visible(False)\n    \n    return fig\napp = App(app_ui, server)",
    "crumbs": [
      "Modul 2: Frequently Updated",
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Bayesian vs. Frequentist</span>"
    ]
  },
  {
    "objectID": "index.html#bayesian-thinking",
    "href": "index.html#bayesian-thinking",
    "title": "Thinking Bayesian",
    "section": "Bayesian Thinking",
    "text": "Bayesian Thinking\nHerzlich willkommen zu diesem Self-Paced Workshop.\nHier lernst du nicht nur graue Theorie, sondern entwickelst ein intuitives GefÃ¼hl fÃ¼r Bayesianische Statistik. Wir nutzen moderne Tools, um Konzepte sichtbar und anfassbar zu machen.\nDas Besondere: Dieser Kurs ist vollkommen interaktiv. Alle Diagramme, Simulationen und Modelle laufen direkt hier in deinem Browser.\n\nWas dich erwartet\n\nğŸ“ Intuition statt Formel-WÃ¼ste: Wir starten mit dem â€œWarumâ€.\nğŸ Modernes Python: Wir nutzen den neuen Shiny-fÃ¼r-Python Stack.\nâš¡ Interaktiv: Keine statischen Bilder. Du steuerst die Parameter.",
    "crumbs": [
      "Willkommen"
    ]
  }
]