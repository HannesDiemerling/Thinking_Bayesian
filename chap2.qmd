---
title: "2. Der Parameter-Raum"
format: html
---

## Zeit: 15 min | Schwierigkeit: Fortgeschritten

### Theorie: Die Landkarte der Wahrscheinlichkeit
Normalerweise denken wir im "Daten-Raum" (x-Achse und y-Achse). Um Modelle zu verstehen, müssen wir lernen, im "Parameter-Raum" zu denken.

* **Links (Parameter-Raum):** Die Achsen sind $\alpha$ und $\beta$. Jeder einzelne Punkt hier definiert eine komplette Kombination aus Intercept und Steigung.
* **Rechts (Daten-Raum):** Hier sehen wir die resultierende Gerade durch die Punkte.

Die **Likelihood** ist unser Kompass. Sie sagt uns, welche Kombination aus $\alpha$ und $\beta$ die beobachteten Daten am besten erklärt. In der Heatmap links entsprechen helle (gelbe) Bereiche einer hohen Wahrscheinlichkeit.

### Ihre Aufgabe
Wir suchen die "beste" Gerade manuell, um zu verstehen, was der Computer tut ("Fitting").
1.  **Klicken** Sie in den linken Plot auf einen beliebigen Punkt. Sehen Sie rechts, wie die Linie entsteht.
2.  Beobachten Sie den **SSR-Wert** (Sum of Squared Residuals). Das ist der Fehler. Ihr Ziel ist es, diesen Wert so klein wie möglich zu machen.
3.  Versuchen Sie, den **grünen Punkt** (die Wahrheit) zu finden, indem Sie sich an den Farben der Heatmap orientieren.
   
```{shinylive-python}
#| standalone: true
#| viewerHeight: 650
#| requirements: numpy, matplotlib, scipy

from shiny import App, render, ui
import numpy as np
import matplotlib.pyplot as plt

# Fixierte Daten (Global definiert für Konsistenz)
np.random.seed(1)
x_data = np.random.uniform(2, 8, 15)
true_a, true_b = 10, 4.5
y_data = true_a + true_b * x_data + np.random.normal(0, 4, 15)

app_ui = ui.page_fluid(
    ui.row(
        ui.column(6, 
            ui.card(
                ui.card_header("1. Parameter Raum (Klicken!)"),
                ui.output_plot("param_plot", click=True),
                ui.div(
                    ui.output_text_verbatim("score_display"),
                    style="font-family: monospace; font-weight:bold; color:#2c3e50; margin-top:10px;"
                )
            )
        ),
        ui.column(6, 
            ui.card(
                ui.card_header("2. Daten Raum (Resultat)"),
                ui.output_plot("data_plot")
            )
        )
    )
)

def server(input, output, session):
    # Startwert (Initial Guess)
    click_coords = ui.reactive.Value({'x': 0, 'y': 0}) 

    @ui.reactive.Effect
    def _():
        # Reagiert auf Klick im Plot
        click = input.param_plot_click()
        if click:
            click_coords.set({'x': click['x'], 'y': click['y']})

    @render.text
    def score_display():
        curr = click_coords.get()
        # Vektorisierte Berechnung des Fehlers für den aktuellen Punkt
        y_est = curr['x'] + curr['y'] * x_data
        ssr = np.sum((y_data - y_est)**2)
        return f"Fehler (SSR): {ssr:.1f} (Ziel: < 250)"

    @render.plot
    def param_plot():
        # Grid Definition
        n = 50 # Auflösung des Grids
        a_grid = np.linspace(-10, 40, n)
        b_grid = np.linspace(-2, 12, n)
        A, B = np.meshgrid(a_grid, b_grid)
        
        # VEKTORISIERUNG STATT LOOPS (Performance Fix!)
        # Wir nutzen NumPy Broadcasting, um alle Kombinationen gleichzeitig zu rechnen
        # A, B shape: (n, n) -> erweitern auf (n, n, 1)
        A_exp = A[:, :, np.newaxis]
        B_exp = B[:, :, np.newaxis]
        
        # Daten shape: (m,) -> erweitern auf (1, 1, m)
        x_exp = x_data[np.newaxis, np.newaxis, :]
        y_exp = y_data[np.newaxis, np.newaxis, :]
        
        # Berechnung über alle Dimensionen gleichzeitig
        y_est_grid = A_exp + B_exp * x_exp
        ssr_grid = np.sum((y_exp - y_est_grid)**2, axis=2)
        
        # Likelihood Transformation (für Visualisierung)
        Z = np.exp(-ssr_grid / 200)

        fig, ax = plt.subplots(figsize=(5, 5))
        
        # Contour Plot
        c = ax.contourf(A, B, Z, levels=15, cmap='viridis')
        
        # Markierungen
        ax.plot(true_a, true_b, 'gX', markersize=10, label='Wahrheit')
        curr = click_coords.get()
        ax.plot(curr['x'], curr['y'], 'rPc', markersize=12, markeredgecolor='white', label='Ihr Klick')
        
        ax.set_xlabel("Alpha (Intercept)")
        ax.set_ylabel("Beta (Slope)")
        ax.legend(loc='lower right', frameon=True)
        return fig

    @render.plot
    def data_plot():
        curr = click_coords.get()
        fig, ax = plt.subplots(figsize=(5, 5))
        
        # Plot Daten
        ax.scatter(x_data, y_data, c='blue', s=50, alpha=0.6, label='Daten')
        
        # Plot User Line
        x_r = np.array([0, 10])
        y_r = curr['x'] + curr['y'] * x_r
        ax.plot(x_r, y_r, color='red', lw=3, label='Ihre Linie')
        
        # Plot Wahre Linie (Referenz)
        y_true = true_a + true_b * x_r
        ax.plot(x_r, y_true, color='green', lw=1, linestyle='--', label='Wahre Linie')
        
        # Fehlerbalken (Residuen)
        y_est_points = curr['x'] + curr['y'] * x_data
        ax.vlines(x_data, y_data, y_est_points, color='red', alpha=0.2)
        
        ax.set_ylim(-20, 80)
        ax.set_xlim(0, 10)
        ax.legend()
        ax.grid(True, alpha=0.3)
        return fig

app = App(app_ui, server)
```