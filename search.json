[
  {
    "objectID": "chap2.html",
    "href": "chap2.html",
    "title": "2. The Interval Fallacy",
    "section": "",
    "text": "A 95% Credible Interval actually implies probability, unlike a Confidence Interval. Use the slider to shade the High Density Interval using seaborn styling.\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\nfrom shiny import App, render, ui\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.input_slider(\"mu\", \"Posterior Mean\", -5, 5, 0),\n            ui.input_slider(\"sigma\", \"Posterior Std\", 0.1, 3, 1),\n            ui.input_slider(\"ci\", \"Credible Mass\", 0.5, 0.99, 0.95, step=0.01)\n        ),\n        ui.card(\n            ui.output_plot(\"hdi_plot\")\n        )\n    )\n)\n\ndef server(input, output, session):\n    @render.plot\n    def hdi_plot():\n        mu = input.mu()\n        sd = input.sigma()\n        ci_mass = input.ci()\n        \n        x = np.linspace(mu - 4*sd, mu + 4*sd, 500)\n        y = norm.pdf(x, mu, sd)\n        \n        sns.set_theme(style=\"ticks\")\n        fig, ax = plt.subplots(figsize=(10, 5))\n        \n        # Main density\n        sns.lineplot(x=x, y=y, color=\"black\", ax=ax)\n        \n        # HDI Calculation (Symmetric for Normal)\n        tail = (1 - ci_mass) / 2\n        lb = norm.ppf(tail, mu, sd)\n        ub = norm.ppf(1 - tail, mu, sd)\n        \n        # Shading\n        mask = (x &gt;= lb) & (x &lt;= ub)\n        ax.fill_between(x, y, where=mask, color=\"#4CB391\", alpha=0.6, label=f\"{ci_mass*100:.0f}% HDI\")\n        \n        # Annotations\n        ax.text(mu, max(y)*0.4, f\"[{lb:.2f}, {ub:.2f}]\", \n                ha='center', fontsize=12, fontweight='bold', color='white')\n        \n        ax.set_title(\"Posterior Distribution & Credible Interval\")\n        ax.legend()\n        sns.despine()\n        \n        return fig\n\napp = App(app_ui, server)",
    "crumbs": [
      "2. The Interval Fallacy"
    ]
  },
  {
    "objectID": "chap2.html#highest-density-interval-hdi",
    "href": "chap2.html#highest-density-interval-hdi",
    "title": "2. The Interval Fallacy",
    "section": "",
    "text": "A 95% Credible Interval actually implies probability, unlike a Confidence Interval. Use the slider to shade the High Density Interval using seaborn styling.\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\nfrom shiny import App, render, ui\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.input_slider(\"mu\", \"Posterior Mean\", -5, 5, 0),\n            ui.input_slider(\"sigma\", \"Posterior Std\", 0.1, 3, 1),\n            ui.input_slider(\"ci\", \"Credible Mass\", 0.5, 0.99, 0.95, step=0.01)\n        ),\n        ui.card(\n            ui.output_plot(\"hdi_plot\")\n        )\n    )\n)\n\ndef server(input, output, session):\n    @render.plot\n    def hdi_plot():\n        mu = input.mu()\n        sd = input.sigma()\n        ci_mass = input.ci()\n        \n        x = np.linspace(mu - 4*sd, mu + 4*sd, 500)\n        y = norm.pdf(x, mu, sd)\n        \n        sns.set_theme(style=\"ticks\")\n        fig, ax = plt.subplots(figsize=(10, 5))\n        \n        # Main density\n        sns.lineplot(x=x, y=y, color=\"black\", ax=ax)\n        \n        # HDI Calculation (Symmetric for Normal)\n        tail = (1 - ci_mass) / 2\n        lb = norm.ppf(tail, mu, sd)\n        ub = norm.ppf(1 - tail, mu, sd)\n        \n        # Shading\n        mask = (x &gt;= lb) & (x &lt;= ub)\n        ax.fill_between(x, y, where=mask, color=\"#4CB391\", alpha=0.6, label=f\"{ci_mass*100:.0f}% HDI\")\n        \n        # Annotations\n        ax.text(mu, max(y)*0.4, f\"[{lb:.2f}, {ub:.2f}]\", \n                ha='center', fontsize=12, fontweight='bold', color='white')\n        \n        ax.set_title(\"Posterior Distribution & Credible Interval\")\n        ax.legend()\n        sns.despine()\n        \n        return fig\n\napp = App(app_ui, server)",
    "crumbs": [
      "2. The Interval Fallacy"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "chap1.html",
    "href": "chap1.html",
    "title": "1. The Conjugate Balance",
    "section": "",
    "text": "The posterior is the compromise between your prior belief and the data. We use a Beta-Binomial conjugate model here. Observe how seaborn renders the density overlaps.\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\nfrom shiny import App, render, ui\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom scipy.stats import beta\nimport pandas as pd\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.h4(\"Parameters\"),\n            ui.input_slider(\"alpha\", \"Prior Alpha (Success)\", 1, 50, 5),\n            ui.input_slider(\"beta_param\", \"Prior Beta (Failure)\", 1, 50, 5),\n            ui.hr(),\n            ui.input_slider(\"succ\", \"Data: Successes\", 0, 100, 20),\n            ui.input_slider(\"fail\", \"Data: Failures\", 0, 100, 5)\n        ),\n        ui.card(\n            ui.output_plot(\"dist_plot\")\n        )\n    )\n)\n\ndef server(input, output, session):\n    @render.plot\n    def dist_plot():\n        # Parameters\n        a_prior = input.alpha()\n        b_prior = input.beta_param()\n        data_s = input.succ()\n        data_f = input.fail()\n        \n        a_post = a_prior + data_s\n        b_post = b_prior + data_f\n        \n        # Grid\n        x = np.linspace(0, 1, 300)\n        \n        # Dataframe for Seaborn\n        # We construct the PDF values manually to overlay them cleanly\n        df = pd.DataFrame({\n            'x': np.tile(x, 2),\n            'y': np.concatenate([\n                beta.pdf(x, a_prior, b_prior),\n                beta.pdf(x, a_post, b_post)\n            ]),\n            'Distribution': ['Prior'] * 300 + ['Posterior'] * 300\n        })\n        \n        # Plotting\n        sns.set_theme(style=\"whitegrid\")\n        fig, ax = plt.subplots(figsize=(10, 6))\n        \n        # Plot Prior and Posterior\n        sns.lineplot(data=df, x='x', y='y', hue='Distribution', \n                     palette={'Prior': 'gray', 'Posterior': 'firebrick'}, \n                     linewidth=2.5, ax=ax)\n        \n        # Fill areas\n        ax.fill_between(x, beta.pdf(x, a_prior, b_prior), color='gray', alpha=0.2)\n        ax.fill_between(x, beta.pdf(x, a_post, b_post), color='firebrick', alpha=0.3)\n        \n        # Likelihood (scaled for visibility)\n        lik = beta.pdf(x, 1+data_s, 1+data_f)\n        ax.plot(x, lik, linestyle='--', color='blue', alpha=0.6, label='Likelihood (Scaled)')\n        \n        ax.set_title(f\"Update: Prior Mean {a_prior/(a_prior+b_prior):.2f} → Post Mean {a_post/(a_post+b_post):.2f}\")\n        ax.set_xlabel(\"Theta (Probability)\")\n        ax.set_ylabel(\"Density\")\n        ax.legend()\n        \n        return fig\n\napp = App(app_ui, server)",
    "crumbs": [
      "1. The Conjugate Balance"
    ]
  },
  {
    "objectID": "chap1.html#prior-vs.-likelihood-strength",
    "href": "chap1.html#prior-vs.-likelihood-strength",
    "title": "1. The Conjugate Balance",
    "section": "",
    "text": "The posterior is the compromise between your prior belief and the data. We use a Beta-Binomial conjugate model here. Observe how seaborn renders the density overlaps.\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\nfrom shiny import App, render, ui\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom scipy.stats import beta\nimport pandas as pd\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.h4(\"Parameters\"),\n            ui.input_slider(\"alpha\", \"Prior Alpha (Success)\", 1, 50, 5),\n            ui.input_slider(\"beta_param\", \"Prior Beta (Failure)\", 1, 50, 5),\n            ui.hr(),\n            ui.input_slider(\"succ\", \"Data: Successes\", 0, 100, 20),\n            ui.input_slider(\"fail\", \"Data: Failures\", 0, 100, 5)\n        ),\n        ui.card(\n            ui.output_plot(\"dist_plot\")\n        )\n    )\n)\n\ndef server(input, output, session):\n    @render.plot\n    def dist_plot():\n        # Parameters\n        a_prior = input.alpha()\n        b_prior = input.beta_param()\n        data_s = input.succ()\n        data_f = input.fail()\n        \n        a_post = a_prior + data_s\n        b_post = b_prior + data_f\n        \n        # Grid\n        x = np.linspace(0, 1, 300)\n        \n        # Dataframe for Seaborn\n        # We construct the PDF values manually to overlay them cleanly\n        df = pd.DataFrame({\n            'x': np.tile(x, 2),\n            'y': np.concatenate([\n                beta.pdf(x, a_prior, b_prior),\n                beta.pdf(x, a_post, b_post)\n            ]),\n            'Distribution': ['Prior'] * 300 + ['Posterior'] * 300\n        })\n        \n        # Plotting\n        sns.set_theme(style=\"whitegrid\")\n        fig, ax = plt.subplots(figsize=(10, 6))\n        \n        # Plot Prior and Posterior\n        sns.lineplot(data=df, x='x', y='y', hue='Distribution', \n                     palette={'Prior': 'gray', 'Posterior': 'firebrick'}, \n                     linewidth=2.5, ax=ax)\n        \n        # Fill areas\n        ax.fill_between(x, beta.pdf(x, a_prior, b_prior), color='gray', alpha=0.2)\n        ax.fill_between(x, beta.pdf(x, a_post, b_post), color='firebrick', alpha=0.3)\n        \n        # Likelihood (scaled for visibility)\n        lik = beta.pdf(x, 1+data_s, 1+data_f)\n        ax.plot(x, lik, linestyle='--', color='blue', alpha=0.6, label='Likelihood (Scaled)')\n        \n        ax.set_title(f\"Update: Prior Mean {a_prior/(a_prior+b_prior):.2f} → Post Mean {a_post/(a_post+b_post):.2f}\")\n        ax.set_xlabel(\"Theta (Probability)\")\n        ax.set_ylabel(\"Density\")\n        ax.legend()\n        \n        return fig\n\napp = App(app_ui, server)",
    "crumbs": [
      "1. The Conjugate Balance"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Workshop Overview",
    "section": "",
    "text": "This workshop addresses common errors in Bayesian reasoning using interactive Python simulations.\nStack: * Engine: Quarto + Shinylive (WASM) * Visualization: Seaborn + Matplotlib * CI/CD: GitHub Actions\nSelect a chapter on the left to begin.",
    "crumbs": [
      "Workshop Overview"
    ]
  },
  {
    "objectID": "index.html#bayesian-statistics-the-misconceptions",
    "href": "index.html#bayesian-statistics-the-misconceptions",
    "title": "Workshop Overview",
    "section": "",
    "text": "This workshop addresses common errors in Bayesian reasoning using interactive Python simulations.\nStack: * Engine: Quarto + Shinylive (WASM) * Visualization: Seaborn + Matplotlib * CI/CD: GitHub Actions\nSelect a chapter on the left to begin.",
    "crumbs": [
      "Workshop Overview"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Setup & Installation",
    "section": "",
    "text": "Das Beste vorweg: Du brauchst keine Software zu installieren, um diesen Workshop durchzuführen.\nDank moderner WebAssembly-Technologie (WASM) läuft der gesamte Python-Code, den du hier siehst, direkt in deinem Browser. Dein Computer ist der Server.\n\n\nLehne dich zurück. Wenn du die interaktiven Apps siehst, hat dein Browser bereits im Hintergrund eine kleine Python-Umgebung geladen.\n\n✅ Keine Installation\n✅ Funktioniert auf Windows, Mac, Linux & iPad\n✅ Datenschutzfreundlich (Daten verlassen deinen PC nicht)\n\n\n\n\n\n\n\nNoteLadezeit\n\n\n\nBeim allerersten Laden einer Seite kann es 1-2 Sekunden dauern, bis Python initialisiert ist. Danach geht es blitzschnell.\n\n\n\n\n\n\nUm den Workshop lokal zu bauen und zu betrachten, folge diesen Schritten:\n\n\nStelle sicher, dass die folgenden Programme installiert sind: * Quarto CLI: https://quarto.org/docs/get-started/ * VS Code Extension: Suche im Marketplace nach “Quarto”. * Python: https://www.python.org/\n\n\n\nÖffne dein Terminal und führe aus: git clone https://github.com/HannesDiemerling/Thinking_Bayesian cd Thinking_Bayesian\n\n\n\nErstelle eine virtuelle Umgebung und installiere die benötigten Pakete: python -m venv venv source venv/bin/activate # Windows: venv pip install jupyter nbformat nbclient # Falls bayesianische Modelle gerechnet werden, zusätzlich: # pip install pymc arviz bambi\n\n\n\nGib folgenden Befehl im VS Code Terminal ein: quarto preview\nDie Website öffnet sich automatisch im Browser und aktualisiert sich bei jeder Speicherung.\n\n\n\n\n\nquarto preview: Startet den lokalen Server mit Live-Reload.\nquarto render: Erstellt die finalen HTML-Dateien im Ordner _book.\nquarto clean: Löscht alle temporären Render-Dateien und den Cache.\n\n\n\n\n\n_quarto.yml: Zentrale Konfiguration (Navigation, Theme, Metadaten).\nindex.qmd: Die Startseite.\n*.qmd: Die einzelnen Kapitel des Buches.\n_book/: Der generierte HTML-Output."
  },
  {
    "objectID": "setup.html#option-a-der-browser-weg-empfohlen",
    "href": "setup.html#option-a-der-browser-weg-empfohlen",
    "title": "Setup & Installation",
    "section": "",
    "text": "Lehne dich zurück. Wenn du die interaktiven Apps siehst, hat dein Browser bereits im Hintergrund eine kleine Python-Umgebung geladen.\n\n✅ Keine Installation\n✅ Funktioniert auf Windows, Mac, Linux & iPad\n✅ Datenschutzfreundlich (Daten verlassen deinen PC nicht)\n\n\n\n\n\n\n\nNoteLadezeit\n\n\n\nBeim allerersten Laden einer Seite kann es 1-2 Sekunden dauern, bis Python initialisiert ist. Danach geht es blitzschnell."
  },
  {
    "objectID": "setup.html#option-b-lokal-mit-vs-code-für-profis",
    "href": "setup.html#option-b-lokal-mit-vs-code-für-profis",
    "title": "Setup & Installation",
    "section": "",
    "text": "Um den Workshop lokal zu bauen und zu betrachten, folge diesen Schritten:\n\n\nStelle sicher, dass die folgenden Programme installiert sind: * Quarto CLI: https://quarto.org/docs/get-started/ * VS Code Extension: Suche im Marketplace nach “Quarto”. * Python: https://www.python.org/\n\n\n\nÖffne dein Terminal und führe aus: git clone https://github.com/HannesDiemerling/Thinking_Bayesian cd Thinking_Bayesian\n\n\n\nErstelle eine virtuelle Umgebung und installiere die benötigten Pakete: python -m venv venv source venv/bin/activate # Windows: venv pip install jupyter nbformat nbclient # Falls bayesianische Modelle gerechnet werden, zusätzlich: # pip install pymc arviz bambi\n\n\n\nGib folgenden Befehl im VS Code Terminal ein: quarto preview\nDie Website öffnet sich automatisch im Browser und aktualisiert sich bei jeder Speicherung."
  },
  {
    "objectID": "setup.html#befehlsreferenz",
    "href": "setup.html#befehlsreferenz",
    "title": "Setup & Installation",
    "section": "",
    "text": "quarto preview: Startet den lokalen Server mit Live-Reload.\nquarto render: Erstellt die finalen HTML-Dateien im Ordner _book.\nquarto clean: Löscht alle temporären Render-Dateien und den Cache."
  },
  {
    "objectID": "setup.html#struktur",
    "href": "setup.html#struktur",
    "title": "Setup & Installation",
    "section": "",
    "text": "_quarto.yml: Zentrale Konfiguration (Navigation, Theme, Metadaten).\nindex.qmd: Die Startseite.\n*.qmd: Die einzelnen Kapitel des Buches.\n_book/: Der generierte HTML-Output."
  },
  {
    "objectID": "chap3.html",
    "href": "chap3.html",
    "title": "3. Convergence Trace",
    "section": "",
    "text": "As \\(N\\) increases, the posterior variance collapses. This plot traces the error of the estimated mean against the true mean using a seaborn trace plot.\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\nfrom shiny import App, render, ui, reactive\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.input_action_button(\"step\", \"Add 50 Samples\", class_=\"btn-primary\"),\n            ui.input_action_button(\"reset\", \"Reset\", class_=\"btn-outline-danger\"),\n            ui.hr(),\n            ui.output_text_verbatim(\"info\")\n        ),\n        ui.card(\n            ui.output_plot(\"trace_plot\")\n        )\n    )\n)\n\ndef server(input, output, session):\n    # State: list of running means\n    state = reactive.Value(pd.DataFrame(columns=['n', 'mean_est', 'upper', 'lower']))\n    true_mu = 2.0\n    true_sigma = 3.0\n    \n    @reactive.Effect\n    @reactive.event(input.step)\n    def _():\n        current_df = state.get()\n        start_n = current_df['n'].max() if not current_df.empty else 0\n        \n        # Simulate batch\n        new_n = start_n + 50\n        # Generate full dataset up to new_n to calculate cumulative mean easier\n        # In prod, optimize this. For workshop, this is fine.\n        data = np.random.normal(true_mu, true_sigma, int(new_n))\n        \n        mu_est = np.mean(data)\n        sem = true_sigma / np.sqrt(new_n) # Standard Error\n        \n        new_row = pd.DataFrame({\n            'n': [new_n], \n            'mean_est': [mu_est],\n            'upper': [mu_est + 1.96*sem],\n            'lower': [mu_est - 1.96*sem]\n        })\n        \n        state.set(pd.concat([current_df, new_row], ignore_index=True))\n\n    @reactive.Effect\n    @reactive.event(input.reset)\n    def _():\n        state.set(pd.DataFrame(columns=['n', 'mean_est', 'upper', 'lower']))\n\n    @render.text\n    def info():\n        df = state.get()\n        if df.empty: return \"No data.\"\n        last = df.iloc[-1]\n        return f\"N={int(last['n'])}, Estimate={last['mean_est']:.3f}\"\n\n    @render.plot\n    def trace_plot():\n        df = state.get()\n        sns.set_theme(style=\"darkgrid\")\n        fig, ax = plt.subplots(figsize=(10, 6))\n        \n        ax.axhline(true_mu, color='red', linestyle='--', label='True Mean')\n        \n        if not df.empty:\n            sns.lineplot(data=df, x='n', y='mean_est', marker='o', color='purple', ax=ax, label='Estimate')\n            ax.fill_between(df['n'], df['lower'], df['upper'], color='purple', alpha=0.2)\n        \n        ax.set_ylim(true_mu - 2, true_mu + 2)\n        ax.set_ylabel(\"Parameter Estimate\")\n        ax.set_xlabel(\"Sample Size (N)\")\n        ax.set_title(\"Convergence of Posterior Mean\")\n        return fig\n\napp = App(app_ui, server)",
    "crumbs": [
      "3. Convergence Trace"
    ]
  },
  {
    "objectID": "chap3.html#visualizing-convergence",
    "href": "chap3.html#visualizing-convergence",
    "title": "3. Convergence Trace",
    "section": "",
    "text": "As \\(N\\) increases, the posterior variance collapses. This plot traces the error of the estimated mean against the true mean using a seaborn trace plot.\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\nfrom shiny import App, render, ui, reactive\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.input_action_button(\"step\", \"Add 50 Samples\", class_=\"btn-primary\"),\n            ui.input_action_button(\"reset\", \"Reset\", class_=\"btn-outline-danger\"),\n            ui.hr(),\n            ui.output_text_verbatim(\"info\")\n        ),\n        ui.card(\n            ui.output_plot(\"trace_plot\")\n        )\n    )\n)\n\ndef server(input, output, session):\n    # State: list of running means\n    state = reactive.Value(pd.DataFrame(columns=['n', 'mean_est', 'upper', 'lower']))\n    true_mu = 2.0\n    true_sigma = 3.0\n    \n    @reactive.Effect\n    @reactive.event(input.step)\n    def _():\n        current_df = state.get()\n        start_n = current_df['n'].max() if not current_df.empty else 0\n        \n        # Simulate batch\n        new_n = start_n + 50\n        # Generate full dataset up to new_n to calculate cumulative mean easier\n        # In prod, optimize this. For workshop, this is fine.\n        data = np.random.normal(true_mu, true_sigma, int(new_n))\n        \n        mu_est = np.mean(data)\n        sem = true_sigma / np.sqrt(new_n) # Standard Error\n        \n        new_row = pd.DataFrame({\n            'n': [new_n], \n            'mean_est': [mu_est],\n            'upper': [mu_est + 1.96*sem],\n            'lower': [mu_est - 1.96*sem]\n        })\n        \n        state.set(pd.concat([current_df, new_row], ignore_index=True))\n\n    @reactive.Effect\n    @reactive.event(input.reset)\n    def _():\n        state.set(pd.DataFrame(columns=['n', 'mean_est', 'upper', 'lower']))\n\n    @render.text\n    def info():\n        df = state.get()\n        if df.empty: return \"No data.\"\n        last = df.iloc[-1]\n        return f\"N={int(last['n'])}, Estimate={last['mean_est']:.3f}\"\n\n    @render.plot\n    def trace_plot():\n        df = state.get()\n        sns.set_theme(style=\"darkgrid\")\n        fig, ax = plt.subplots(figsize=(10, 6))\n        \n        ax.axhline(true_mu, color='red', linestyle='--', label='True Mean')\n        \n        if not df.empty:\n            sns.lineplot(data=df, x='n', y='mean_est', marker='o', color='purple', ax=ax, label='Estimate')\n            ax.fill_between(df['n'], df['lower'], df['upper'], color='purple', alpha=0.2)\n        \n        ax.set_ylim(true_mu - 2, true_mu + 2)\n        ax.set_ylabel(\"Parameter Estimate\")\n        ax.set_xlabel(\"Sample Size (N)\")\n        ax.set_title(\"Convergence of Posterior Mean\")\n        return fig\n\napp = App(app_ui, server)",
    "crumbs": [
      "3. Convergence Trace"
    ]
  }
]